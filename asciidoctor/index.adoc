= Groovy Integration Testing with Spock and Docker
Kevin Wittek <https://github.com/kiview[icon:github[] @kiview]>

++++
<a href="https://github.com/kiview/testcontainers-groovy-integration-tests-workshop"><img style="position: fixed; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
++++

== Getting started

To complete this workshop, you should have installed locally:

* JDK 8
* GIT
* Docker 17-CE
* Linux environment recommended
** Using _Docker for Windows_ and _Docker for Mac_ should work as well, but we might struggle in helping with problems on these systems ;)

Generals experience in using the following technologies is expected. You can tag along if you don't
know all the details, but some topics might get too complex if you are missing the basics.

* Java
* JUnit4
* Docker

Also, although not mandatory, it's highly recommended to use https://www.jetbrains.com/idea/[IntelliJ IDEA], arguably
the best IDE for Java and JVM language development. You can just use the Community Edition if you want to (which will miss Groovy support).

=== Testcontainers Quickstart

____
https://github.com/testcontainers/testcontainers-java[Testcontainers] is a Java 8 library that supports JUnit tests, providing lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container.
____

There also exists a special https://github.com/testcontainers/testcontainers-spock[Testcontainers-Spock-Extension] which
we'll use later in this workshop (it also includes the Java version as a transitive dependency).

Since the most recent snapshot versions are available at https://jitpack.io/[jitpack.io], you can
include the dependency in your `build.gradle` file like this:

[source, groovy]
----
repositories {
    mavenCentral()
    maven { url 'https://jitpack.io' }
}

dependencies {
    testCompile 'com.github.testcontainers:testcontainers-spock:1.0.0-tc1.6.0'
}
----

==== Using Testcontainers
You can find an extensive documentation about using Testcontainers https://www.testcontainers.org/[here], so we will just a quick overview in this chapter.

Testcontainers can be used in JUnit4 tests by initializing Testcontainers objects as fields of the test class and by either annotating these fields with `@Rule` or `@ClassRule` JUnit4 annotation. `@Rule` means, the container will be restarted between each test method, `@ClassRule` will result in reusing the same container for all test methods of the test class. Testcontainers utilizes a fluent builder API for creating containers, this is an example:

[source, java]
----
// Set up a redis container
@ClassRule
public static GenericContainer redis =
    new GenericContainer("redis:3.0.2")
               .withExposedPorts(6379);


// Set up a plain OS container and customize environment, 
// command and exposed ports. This just listens on port 80 
// and always returns '42'
@ClassRule
public static GenericContainer alpine =
    new GenericContainer("alpine:3.2")
            .withExposedPorts(80)
               .withEnv("MAGIC_NUMBER", "42")
               .withCommand("/bin/sh", "-c", 
               "while true; do echo \"$MAGIC_NUMBER\" | nc -l -p 80; done");
----

`GenericContainer` is a special Testcontainers class and can be used for every Docker image, for which no specialized Testcontainers implementation exists. Existing specialized container classes are i.e. `PostgreSQLContainer`, `MySQLContainer` or `BrowserWebDriverContainer`. These specialized containers might provide additinal API methods for more convenient usage inside tests, like `getJdbcUrl()` in case of database containers.

== Integration testing using a real database

A classic use case for integration testing is the persistence layer. An ofen found default approach is to use an embedded H2 in-memory database and run each test inside its own database transaction, which is rolled back after each test method.
This might work for a lot use case, but sometimes it's beneficial to use a real database for the integration tests, which
will provide you with the extra level of confidence regarding vendor specific SQL features or more complex queries.

TestContainers provides out of the box support for the following databases:

* MySQL
* PostgreSQL
* Oracle XE
* Virtuoso

We'll use PostgreSQL in the following example, so we need to include an additional dependency in our `build.gradle` file:

[source, groovy]
----
// https://mvnrepository.com/artifact/org.testcontainers/postgresql
testCompile group: 'org.testcontainers', name: 'postgresql', version: '1.6.0'
----

=== Configure SUT at runtime

We want our tests to be as portable as possible and so one shouldn't make assumptions regarding the environment they are
running in (like i.e. free ports). Luckily Testcontainers will already do all the heavy lifting for you and start
the database on a free port (by leveraging the underlying container technology). By using methods like `postgreSQLContainer.getJdbcUrl()`
it's possible to get the concrete values a runtime. Of course, production codes need to be written in such a way, that you can inject those values into the SUT at test runtime, i.e. specify such values in the constructor.

=== Exercise 1

Write integration tests for each method of `BookRepository` and implement `BookRepository` accordingly.

[NOTE]
====
You might need additional runtime dependencies!

For the production code it's okay to go completly vanilla Java and use `DriverManager` and https://docs.oracle.com/javase/tutorial/jdbc/basics/connecting.html[`Connection`]. You can use `DriverManager.getConnection(jdbcUrl, username, password)` and `c.createStatement()`.

Also remember to initialize the database schema before the test. Future versions of Testcontainers will prodive special API methods for helping with this (see https://github.com/testcontainers/testcontainers-java/pull/575[PR]), but for now you have to do it manually or use https://flywaydb.org/[Flyway] if you want to.
====

=== TestContainers JDBC-URL

As long as you have Testcontainers and the appropriate JDBC driver on your classpath, you can simply modify regular JDBC
connection URLs to get a fresh containerized instance of the database each time your application starts up (meaning
on initialization of the JDBC connection pool). This can be used as an alternative to the way we've seen in the last exercise.

[CAUTION]
=====
Attention when using Spring-Boot (or Grails for that matter). In this case you have to specify the following JDBC driver:

`spring.datasource.driver-class-name=org.testcontainers.jdbc.ContainerDatabaseDriver`

which would translate to something like this for Grails:

----
dataSource:
  dbCreate: create
  url: jdbc:tc:postgresql://hostname/databasename
  driverClassName: org.testcontainers.jdbc.ContainerDatabaseDriver
----

=====

==== MySQL

----
jdbc:tc:mysql://somehostname:someport/databasename
----

----
jdbc:tc:mysql:5.6.23://somehostname:someport/databasename
----

==== PostgreSQL

----
jdbc:tc:postgresql://hostname/databasename
----

=== Exercise 2

Duplicate the test class you've written in the last exercise and use the special Testcontainers JDBC-URL this time. 
The JDBC-URL approach already supports using an database https://www.testcontainers.org/usage/database_containers.html#using-an-init-script[init script].

== Excursus: Groovy & Spock

TODO

== Interact with an external HTTP-Server

Now we want to think about testing the integration with a real external application. This could be anything
which we'd be able to run inside a container, but in order to keep things simple, we have a very basic example:
Downloading a file from an HTTP-Server.

Let's start with a service class skeleton, which looks like this:

[source, java]
----
public class HttpDownloaderService {

    private String serverIp;

    private String serverPort;

    public HttpDownloaderService(String serverIp, String serverPort) {
        // ...
    }

    public String downloadFile(String path) {
        // ...
    }
}
----


=== Generic Container

For this integration test we want to use an Apache webserver. Fortunately there is a ready to use Docker image: `httpd:alpine`

Testcontainers provides a generic API for Docker images called `GenericContainer`. We also need to tell Testcontainers which port
we want the container to expose and as before, Testcontainers will find use a free port on our host system and setup up
the appropriate mapping.

We might also want to have some specific files on the server we can use for our tests and Testcontainers will allow us
to mount files on the classpath into the container:

[source, java]
----
GenericContainer httpContainer = new GenericContainer("httpd:alpine")
            .withExposedPorts(80)
            .withClasspathResourceMapping("foo.txt", "/usr/local/apache2/htdocs/foo.txt", BindMode.READ_ONLY);
----

The `GenericContainer` interface also provides the methods to retrieve the actual container ip and port at runtime:

[source, java]
----
httpContainer.getContainerIpAddress();
httpContainer.getMappedPort(80);
----

=== Exercise 3

Write an integration test as well as the corresponding production code to make the test green. You might want to use
the wonderful new https://github.com/http-builder-ng/http-builder-ng[HttpBuilder-NG] for the implementation code:

[source, groovy]
----
compile 'io.github.http-builder-ng:http-builder-ng-core:0.16.1'
----

== Functional testing using Geb and Selenium

I've prepared an example, we might want to look into:

[source, bash]
----
git clone https://github.com/kiview/example-voting-app.git
----

== Bonus: Testing your Docker containers with Testcontainers and Groovy scripts

TODO

See this https://medium.com/@bsideup/testing-your-docker-containers-with-testcontainers-and-groovy-3b9ef97ad1c2[blog post].

== Acknowledgements

* https://github.com/alvarosanchez[Álvaro Sánchez-Mariscal] and https://github.com/musketyr[Vladimir Orany] for giving me a
kickstart using AsciiDoc for this workshop
